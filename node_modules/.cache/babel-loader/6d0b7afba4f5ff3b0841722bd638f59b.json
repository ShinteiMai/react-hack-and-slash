{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\";\nimport fromApi from \"../api/fromApi\";\nimport { SliceStatus } from \"../globals\";\nimport { camelcaseObject } from \"../utils/camelcaseObject\";\nimport { statusHandlerReducer, transformSpriteToBaseImage, wrapReduxAsyncHandler } from \"./utilities\";\nimport { baseImageUrl } from \"../api/axios\";\nexport const PAGINATE_SIZE = 6;\nconst initialState = {\n  data: [],\n  status: {\n    state: SliceStatus.IDLE\n  }\n};\nconst pokemonsSlice = createSlice({\n  name: \"pokemons\",\n  initialState,\n  reducers: { ...statusHandlerReducer,\n\n    initializePokemonsReducer(state, action) {\n      const {\n        size\n      } = action.payload;\n      const nullValues = new Array(size).fill(null);\n\n      if (state.data.length === 0) {\n        state.data = nullValues;\n      } else {\n        state.data = state.data.concat(nullValues);\n      }\n    },\n\n    getPokemonsReducer(state, action) {\n      const {\n        pokemon,\n        size,\n        index\n      } = action.payload;\n      const isPokemonAlreadyExists = state.data.find(existingPokemon => existingPokemon !== null && existingPokemon.id === pokemon.id);\n\n      if (!isPokemonAlreadyExists) {\n        state.data[state.data.length - (size - index)] = pokemon;\n      }\n    },\n\n    getSinglePokemonReducer(state, action) {\n      const {\n        pokemon\n      } = action.payload;\n      const isPokemonAlreadyExists = state.data.find(existingPokemon => existingPokemon !== null && existingPokemon.id === pokemon.id);\n\n      if (!isPokemonAlreadyExists) {\n        state.data.push(pokemon);\n      }\n    },\n\n    resetPokemonsReducer(state, action) {\n      state.data = [];\n    }\n\n  }\n});\nexport const pokemonsReducer = pokemonsSlice.reducer;\nexport const {\n  initialize,\n  error,\n  success,\n  initializePokemonsReducer,\n  getPokemonsReducer,\n  resetPokemonsReducer,\n  getSinglePokemonReducer\n} = pokemonsSlice.actions;\nexport const pokemonsSelector = state => state.pokemons;\nconst statusHandler = {\n  initialize,\n  error,\n  success\n};\nexport const getPaginatedPokemons = (pokemons, cachedPokemons, page) => {\n  const size = PAGINATE_SIZE - pokemons.length % PAGINATE_SIZE;\n  return {\n    cached: cachedPokemons.slice(page, page + size),\n    size\n  };\n};\nexport const fetchPokemon = async url => {\n  const id = Number(url.split(\"/\").slice(-2)[0]);\n  const pokemonData = await fromApi.getPokemonByNameOrId(id);\n  const imageUrl = transformSpriteToBaseImage(id, baseImageUrl);\n  return { ...camelcaseObject(pokemonData),\n    sprites: {\n      frontDefault: imageUrl\n    }\n  };\n}; // export const getPokemons = wrapReduxAsyncHandler(\n//   statusHandler,\n//   async (dispatch, { page, cachedPokemons, pokemons }) => {\n//     const size = PAGINATE_SIZE - (pokemons.length % PAGINATE_SIZE);\n//     const results = cachedPokemons.slice(page, page + size);\n//     dispatch(initializePokemonsReducer({ size }));\n//     for await (const [index, { url }] of results.entries()) {\n//       const pokemonId = Number(url.split(\"/\").slice(-2)[0]);\n//       const pokemon = await fromApi.getPokemonByNameOrId(pokemonId);\n//       const pokemonImageUrl = transformSpriteToBaseImage(\n//         pokemon.id,\n//         baseImageUrl\n//       );\n//       dispatch(\n//         getPokemonsReducer({\n//           pokemon: {\n//             ...camelcaseObject(pokemon),\n//             sprites: {\n//               frontDefault: pokemonImageUrl,\n//             },\n//           },\n//           size,\n//           index,\n//         })\n//       );\n//     }\n//   }\n// );\n\nexport const getPokemonById = wrapReduxAsyncHandler(statusHandler, async (dispatch, {\n  pokemonId\n}) => {\n  const pokemon = await fromApi.getPokemonByNameOrId(pokemonId);\n  const pokemonImageUrl = transformSpriteToBaseImage(pokemon.id, baseImageUrl);\n  const transformedPokemon = { ...camelcaseObject(pokemon),\n    sprites: {\n      frontDefault: pokemonImageUrl\n    }\n  };\n  dispatch(getSinglePokemonReducer({\n    pokemon: transformedPokemon\n  }));\n});","map":{"version":3,"sources":["/home/shinteimai/workspace/personal/react-pokedex/src/features/pokemonSlice.ts"],"names":["createSlice","fromApi","SliceStatus","camelcaseObject","statusHandlerReducer","transformSpriteToBaseImage","wrapReduxAsyncHandler","baseImageUrl","PAGINATE_SIZE","initialState","data","status","state","IDLE","pokemonsSlice","name","reducers","initializePokemonsReducer","action","size","payload","nullValues","Array","fill","length","concat","getPokemonsReducer","pokemon","index","isPokemonAlreadyExists","find","existingPokemon","id","getSinglePokemonReducer","push","resetPokemonsReducer","pokemonsReducer","reducer","initialize","error","success","actions","pokemonsSelector","pokemons","statusHandler","getPaginatedPokemons","cachedPokemons","page","cached","slice","fetchPokemon","url","Number","split","pokemonData","getPokemonByNameOrId","imageUrl","sprites","frontDefault","getPokemonById","dispatch","pokemonId","pokemonImageUrl","transformedPokemon"],"mappings":"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","sourcesContent":["import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport fromApi from \"../api/fromApi\";\nimport { SliceStatus } from \"../globals\";\nimport { RootState } from \"./store\";\nimport { NamedAPIResource } from \"./types\";\nimport { camelcaseObject } from \"../utils/camelcaseObject\";\nimport {\n  statusHandlerReducer,\n  transformSpriteToBaseImage,\n  wrapReduxAsyncHandler,\n} from \"./utilities\";\nimport { baseImageUrl } from \"../api/axios\";\n\nexport const PAGINATE_SIZE = 6;\n\nexport type Pokemon = {\n  id: number;\n  name: string;\n  baseExperience: number;\n  height: number;\n  isDefault: boolean;\n  order: number;\n  weight: number;\n  abilities: {\n    isHidden: boolean;\n    slot: number;\n    ability: NamedAPIResource;\n  }[];\n  forms: NamedAPIResource[];\n  moves: {\n    move: NamedAPIResource;\n  }[];\n  sprites: {\n    frontDefault: string;\n    frontShiny: string;\n    frontFemale: string;\n    frontShinyFemale: string;\n    backDefault: string;\n    backShiny: string;\n    backFemale: string;\n    backShinyFemale: string;\n  };\n  species: NamedAPIResource[];\n  stats: {\n    baseStat: number;\n    effort: number;\n    stat: NamedAPIResource;\n  }[];\n  types: {\n    slot: number;\n    type: NamedAPIResource;\n  }[];\n};\n\ntype SliceState = {\n  data: (Pokemon | null)[];\n  status: {\n    state: SliceStatus;\n  };\n};\n\nconst initialState: SliceState = {\n  data: [],\n  status: {\n    state: SliceStatus.IDLE,\n  },\n};\n\nconst pokemonsSlice = createSlice({\n  name: \"pokemons\",\n  initialState,\n  reducers: {\n    ...statusHandlerReducer,\n    initializePokemonsReducer(state, action: PayloadAction<{ size: number }>) {\n      const { size } = action.payload;\n      const nullValues = new Array<null>(size).fill(null);\n      if (state.data.length === 0) {\n        state.data = nullValues;\n      } else {\n        state.data = state.data.concat(nullValues);\n      }\n    },\n    getPokemonsReducer(\n      state,\n      action: PayloadAction<{ pokemon: Pokemon; index: number; size: number }>\n    ) {\n      const { pokemon, size, index } = action.payload;\n\n      const isPokemonAlreadyExists = state.data.find(\n        (existingPokemon) =>\n          existingPokemon !== null && existingPokemon.id === pokemon.id\n      );\n      if (!isPokemonAlreadyExists) {\n        state.data[state.data.length - (size - index)] = pokemon;\n      }\n    },\n    getSinglePokemonReducer(\n      state,\n      action: PayloadAction<{ pokemon: Pokemon }>\n    ) {\n      const { pokemon } = action.payload;\n      const isPokemonAlreadyExists = state.data.find(\n        (existingPokemon) =>\n          existingPokemon !== null && existingPokemon.id === pokemon.id\n      );\n      if (!isPokemonAlreadyExists) {\n        state.data.push(pokemon);\n      }\n    },\n    resetPokemonsReducer(state, action) {\n      state.data = [];\n    },\n  },\n});\n\nexport const pokemonsReducer = pokemonsSlice.reducer;\nexport const {\n  initialize,\n  error,\n  success,\n  initializePokemonsReducer,\n  getPokemonsReducer,\n  resetPokemonsReducer,\n  getSinglePokemonReducer,\n} = pokemonsSlice.actions;\n\nexport const pokemonsSelector = (state: RootState) => state.pokemons;\n\nconst statusHandler = { initialize, error, success };\n\nexport const getPaginatedPokemons = (\n  pokemons: Pokemon[],\n  cachedPokemons: (NamedAPIResource & { distance: number })[],\n  page: number\n) => {\n  const size = PAGINATE_SIZE - (pokemons.length % PAGINATE_SIZE);\n  return {\n    cached: cachedPokemons.slice(page, page + size),\n    size,\n  };\n};\n\nexport const fetchPokemon = async (url: string) => {\n  const id = Number(url.split(\"/\").slice(-2)[0]);\n  const pokemonData = await fromApi.getPokemonByNameOrId(id);\n  const imageUrl = transformSpriteToBaseImage(id, baseImageUrl);\n  return {\n    ...camelcaseObject(pokemonData),\n    sprites: {\n      frontDefault: imageUrl,\n    },\n  };\n};\n\n// export const getPokemons = wrapReduxAsyncHandler(\n//   statusHandler,\n//   async (dispatch, { page, cachedPokemons, pokemons }) => {\n//     const size = PAGINATE_SIZE - (pokemons.length % PAGINATE_SIZE);\n//     const results = cachedPokemons.slice(page, page + size);\n//     dispatch(initializePokemonsReducer({ size }));\n\n//     for await (const [index, { url }] of results.entries()) {\n//       const pokemonId = Number(url.split(\"/\").slice(-2)[0]);\n//       const pokemon = await fromApi.getPokemonByNameOrId(pokemonId);\n//       const pokemonImageUrl = transformSpriteToBaseImage(\n//         pokemon.id,\n//         baseImageUrl\n//       );\n\n//       dispatch(\n//         getPokemonsReducer({\n//           pokemon: {\n//             ...camelcaseObject(pokemon),\n//             sprites: {\n//               frontDefault: pokemonImageUrl,\n//             },\n//           },\n//           size,\n//           index,\n//         })\n//       );\n//     }\n//   }\n// );\n\nexport const getPokemonById = wrapReduxAsyncHandler(\n  statusHandler,\n  async (dispatch, { pokemonId }) => {\n    const pokemon = await fromApi.getPokemonByNameOrId(pokemonId);\n    const pokemonImageUrl = transformSpriteToBaseImage(\n      pokemon.id,\n      baseImageUrl\n    );\n    const transformedPokemon = {\n      ...camelcaseObject(pokemon),\n      sprites: { frontDefault: pokemonImageUrl },\n    };\n    dispatch(getSinglePokemonReducer({ pokemon: transformedPokemon }));\n  }\n);\n"]},"metadata":{},"sourceType":"module"}