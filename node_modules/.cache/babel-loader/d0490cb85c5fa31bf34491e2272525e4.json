{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\";\nimport fromApi from \"../api/fromApi\";\nimport { SliceStatus } from \"../globals\";\nimport { camelcaseObject } from \"../utils/camelcaseObject\";\nimport { statusHandlerReducer, wrapReduxAsyncHandler } from \"./utilities\";\nimport { leftPad } from \"../utils/leftPad\";\nimport { baseImageUrl } from \"../api/axios\";\nexport const PAGINATE_SIZE = 6;\nconst initialState = {\n  data: [],\n  status: {\n    state: SliceStatus.IDLE\n  }\n};\nconst pokemonsSlice = createSlice({\n  name: \"pokemons\",\n  initialState,\n  reducers: { ...statusHandlerReducer,\n\n    initializePokemonsReducer(state, action) {\n      const {\n        size\n      } = action.payload;\n      const nullValues = new Array(size - state.data.length % size).fill(null);\n\n      if (state.data.length === 0) {\n        state.data = nullValues;\n      } else {\n        state.data = state.data.concat(nullValues);\n      }\n    },\n\n    getPokemonsReducer(state, action) {\n      const {\n        pokemon,\n        size,\n        index\n      } = action.payload;\n      const isPokemonAlreadyExists = state.data.find(existingPokemon => existingPokemon !== null && existingPokemon.id === pokemon.id);\n\n      if (!isPokemonAlreadyExists) {\n        state.data[state.data.length - (size - index)] = pokemon;\n      }\n    },\n\n    getSinglePokemonReducer(state, action) {\n      const {\n        pokemon\n      } = action.payload;\n      const isPokemonAlreadyExists = state.data.find(existingPokemon => existingPokemon !== null && existingPokemon.id === pokemon.id);\n\n      if (!isPokemonAlreadyExists) {\n        state.data.push(pokemon);\n      }\n    },\n\n    resetPokemonsReducer(state, action) {\n      state.data = [];\n    }\n\n  }\n});\nexport const pokemonsReducer = pokemonsSlice.reducer;\nexport const {\n  initialize,\n  error,\n  success,\n  initializePokemonsReducer,\n  getPokemonsReducer,\n  resetPokemonsReducer,\n  getSinglePokemonReducer\n} = pokemonsSlice.actions;\nexport const pokemonsSelector = state => state.pokemons;\nconst statusHandler = {\n  initialize,\n  error,\n  success\n};\n\nconst transformSpriteToBaseImage = pokemonId => {\n  return baseImageUrl + leftPad(pokemonId, 3) + \".png\";\n};\n\nexport const getPokemons = wrapReduxAsyncHandler(statusHandler, async (dispatch, {\n  page,\n  cachedPokemons\n}) => {\n  const results = cachedPokemons.slice(page, page + PAGINATE_SIZE);\n  dispatch(initializePokemonsReducer({\n    size: PAGINATE_SIZE\n  }));\n\n  for await (const [index, {\n    url\n  }] of results.entries()) {\n    const pokemonId = Number(url.split(\"/\").slice(-2)[0]);\n    const pokemon = await fromApi.getPokemonById(pokemonId);\n    const pokemonImageUrl = transformSpriteToBaseImage(pokemon.id);\n    dispatch(getPokemonsReducer({\n      pokemon: { ...camelcaseObject(pokemon),\n        sprites: {\n          frontDefault: pokemonImageUrl\n        }\n      },\n      size: PAGINATE_SIZE,\n      index\n    }));\n  }\n});\nexport const getPokemonById = wrapReduxAsyncHandler(statusHandler, async (dispatch, {\n  pokemonId\n}) => {\n  const pokemon = await fromApi.getPokemonById(pokemonId);\n  const pokemonImageUrl = transformSpriteToBaseImage(pokemon.id);\n  const transformedPokemon = { ...pokemon,\n    sprites: {\n      frontDefault: pokemonImageUrl\n    }\n  };\n  dispatch(getSinglePokemonReducer({\n    pokemon: transformedPokemon\n  }));\n});","map":{"version":3,"sources":["/home/shinteimai/workspace/personal/react-pokedex/src/features/pokemonSlice.ts"],"names":["createSlice","fromApi","SliceStatus","camelcaseObject","statusHandlerReducer","wrapReduxAsyncHandler","leftPad","baseImageUrl","PAGINATE_SIZE","initialState","data","status","state","IDLE","pokemonsSlice","name","reducers","initializePokemonsReducer","action","size","payload","nullValues","Array","length","fill","concat","getPokemonsReducer","pokemon","index","isPokemonAlreadyExists","find","existingPokemon","id","getSinglePokemonReducer","push","resetPokemonsReducer","pokemonsReducer","reducer","initialize","error","success","actions","pokemonsSelector","pokemons","statusHandler","transformSpriteToBaseImage","pokemonId","getPokemons","dispatch","page","cachedPokemons","results","slice","url","entries","Number","split","getPokemonById","pokemonImageUrl","sprites","frontDefault","transformedPokemon"],"mappings":"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","sourcesContent":["import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport fromApi from \"../api/fromApi\";\nimport { SliceStatus } from \"../globals\";\nimport { RootState } from \"./store\";\nimport { NamedAPIResource } from \"./types\";\nimport { camelcaseObject } from \"../utils/camelcaseObject\";\nimport { statusHandlerReducer, wrapReduxAsyncHandler } from \"./utilities\";\nimport { leftPad } from \"../utils/leftPad\";\nimport { baseImageUrl } from \"../api/axios\";\n\nexport const PAGINATE_SIZE = 6;\n\nexport type Pokemon = {\n  id: number;\n  name: string;\n  baseExperience: number;\n  height: number;\n  isDefault: boolean;\n  order: number;\n  weight: number;\n  abilities: {\n    isHidden: boolean;\n    slot: number;\n    ability: NamedAPIResource;\n  }[];\n  forms: NamedAPIResource[];\n  moves: {\n    move: NamedAPIResource;\n  }[];\n  sprites: {\n    frontDefault: string;\n    frontShiny: string;\n    frontFemale: string;\n    frontShinyFemale: string;\n    backDefault: string;\n    backShiny: string;\n    backFemale: string;\n    backShinyFemale: string;\n  };\n  species: NamedAPIResource[];\n  stats: {\n    baseStat: number;\n    effort: number;\n    stat: NamedAPIResource;\n  }[];\n  types: {\n    slot: number;\n    type: NamedAPIResource;\n  }[];\n};\n\ntype SliceState = {\n  data: (Pokemon | null)[];\n  status: {\n    state: SliceStatus;\n  };\n};\n\nconst initialState: SliceState = {\n  data: [],\n  status: {\n    state: SliceStatus.IDLE,\n  },\n};\n\nconst pokemonsSlice = createSlice({\n  name: \"pokemons\",\n  initialState,\n  reducers: {\n    ...statusHandlerReducer,\n    initializePokemonsReducer(state, action: PayloadAction<{ size: number }>) {\n      const { size } = action.payload;\n      const nullValues = new Array<null>(\n        size - (state.data.length % size)\n      ).fill(null);\n      if (state.data.length === 0) {\n        state.data = nullValues;\n      } else {\n        state.data = state.data.concat(nullValues);\n      }\n    },\n    getPokemonsReducer(\n      state,\n      action: PayloadAction<{ pokemon: Pokemon; index: number; size: number }>\n    ) {\n      const { pokemon, size, index } = action.payload;\n\n      const isPokemonAlreadyExists = state.data.find(\n        (existingPokemon) =>\n          existingPokemon !== null && existingPokemon.id === pokemon.id\n      );\n      if (!isPokemonAlreadyExists) {\n        state.data[state.data.length - (size - index)] = pokemon;\n      }\n    },\n    getSinglePokemonReducer(\n      state,\n      action: PayloadAction<{ pokemon: Pokemon }>\n    ) {\n      const { pokemon } = action.payload;\n      const isPokemonAlreadyExists = state.data.find(\n        (existingPokemon) =>\n          existingPokemon !== null && existingPokemon.id === pokemon.id\n      );\n      if (!isPokemonAlreadyExists) {\n        state.data.push(pokemon);\n      }\n    },\n    resetPokemonsReducer(state, action) {\n      state.data = [];\n    },\n  },\n});\n\nexport const pokemonsReducer = pokemonsSlice.reducer;\nexport const {\n  initialize,\n  error,\n  success,\n  initializePokemonsReducer,\n  getPokemonsReducer,\n  resetPokemonsReducer,\n  getSinglePokemonReducer,\n} = pokemonsSlice.actions;\n\nexport const pokemonsSelector = (state: RootState) => state.pokemons;\n\nconst statusHandler = { initialize, error, success };\n\nconst transformSpriteToBaseImage = (pokemonId: number): string => {\n  return baseImageUrl + leftPad(pokemonId, 3) + \".png\";\n};\n\nexport const getPokemons = wrapReduxAsyncHandler(\n  statusHandler,\n  async (dispatch, { page, cachedPokemons }) => {\n    const results = cachedPokemons.slice(page, page + PAGINATE_SIZE);\n    dispatch(initializePokemonsReducer({ size: PAGINATE_SIZE }));\n\n    for await (const [index, { url }] of results.entries()) {\n      const pokemonId = Number(url.split(\"/\").slice(-2)[0]);\n      const pokemon = await fromApi.getPokemonById(pokemonId);\n      const pokemonImageUrl = transformSpriteToBaseImage(pokemon.id);\n\n      dispatch(\n        getPokemonsReducer({\n          pokemon: {\n            ...camelcaseObject(pokemon),\n            sprites: {\n              frontDefault: pokemonImageUrl,\n            },\n          },\n          size: PAGINATE_SIZE,\n          index,\n        })\n      );\n    }\n  }\n);\n\nexport const getPokemonById = wrapReduxAsyncHandler(\n  statusHandler,\n  async (dispatch, { pokemonId }) => {\n    const pokemon = await fromApi.getPokemonById(pokemonId);\n    const pokemonImageUrl = transformSpriteToBaseImage(pokemon.id);\n    const transformedPokemon = {\n      ...pokemon,\n      sprites: { frontDefault: pokemonImageUrl },\n    };\n    dispatch(getSinglePokemonReducer({ pokemon: transformedPokemon }));\n  }\n);\n"]},"metadata":{},"sourceType":"module"}